# Ktor Routes Codegen

A code generator that creates type-safe routing code from a simple routes file for Ktor applications using
[Kotlin Symbol Processing](https://kotlinlang.org/docs/ksp-overview.html#how-ksp-looks-at-source-files). The routes file follows
[the syntax used in the Play! Framework routes files](https://www.playframework.com/documentation/3.0.x/JavaRouting#The-routes-file-syntax),
so one can have a single place to find a compact, readable overview of all routes. Since the file is handled by KSP,
your routes file is transformed into type-safe, validated code with no runtime overhead.


## Quick Start

### 1. Add the Code Generator to your Build

```kotlin
// build.gradle.kts
plugins {
    kotlin("jvm") version "2.2.0"
    id("com.google.devtools.ksp") version "2.2.0-2.0.2"
}

dependencies {
    implementation("org.babelserver.ktor:ktor-routes-codegen")
    ksp("org.babelserver.ktor:ktor-routes-codegen")
    
    implementation("io.ktor:ktor-server-core:3.2.2")
    implementation("io.ktor:ktor-server-netty:3.2.2")
}
```

### 2. Create Controllers

```kotlin
class UserController {
    suspend fun show(call: ApplicationCall, id: String) {
        call.respondText("User: $id")
    }
    
    suspend fun list(call: ApplicationCall) {
        call.respondText("User list")
    }
}

class ApiController {
    suspend fun getProduct(call: ApplicationCall, id: Int) {
        // id is automatically converted from String to Int
        call.respondText("Product: $id")
    }
}
```

**Note**: `call: ApplicationCall` must be the first parameter in all controller function signatures


### 3. Create the Routes File

Create `src/main/resources/routes`:
```
# Home page
GET     /                           com.example.controllers.HomeController.index()

# User management with path parameters
GET     /users                      com.example.controllers.UserController.list()
GET     /users/:id                  com.example.controllers.UserController.show(id: String)
POST    /users                      com.example.controllers.UserController.create()
PUT     /users/:id                  com.example.controllers.UserController.update(id: String)
DELETE  /users/:id                  com.example.controllers.UserController.delete(id: String)

# API with typed parameters
GET     /api/products/:id           com.example.controllers.ApiController.getProduct(id: Int)
GET     /api/search                 com.example.controllers.ApiController.search(q: String)

# Blog posts with multiple parameters
GET     /blog/:year/:month/:slug    com.example.controllers.BlogController.showPost(year: Int, month: Int, slug: String)
```

**Note**: `call: ApplicationCall` is automatically added as the first parameter to all controller methods and should not
                                  be specified in the routes file.

### 4. Include the @GenerateRoutes Annotation in your Application Class

```kotlin
package com.example

import org.babelserver.ktor.routesfile.GenerateRoutes

@GenerateRoutes
class RoutesConfig // This is just a placeholder. You can name it however you like.
```

### 5. Use the Generated Routes

```kotlin
fun main() {
    embeddedServer(Netty, port = 8080, host = "0.0.0.0") {
        val generatedRoutes = GeneratedRoutes() // the GeneratedRoutes class is generated in the build process
        generatedRoutes.configureRoutes(routing)
    }.start(wait = true)
}
```

## Generated Code

The code generator creates routing code like this:

```kotlin
// Generated by KSP
class GeneratedRoutes {
    private val homeController: HomeController = HomeController()
    private val userController: UserController = UserController()
    private val apiController: ApiController = ApiController()
    
    fun configureRoutes(routing: Routing) {
        routing.apply {
            get("/users/{id}") {
                val id: String = call.parameters["id"] ?: throw BadRequestException("Missing parameter: id")
                userController.show(call, id)
            }
            get("/api/products/{id}") {
                val id: Int = call.parameters["id"]?.toIntOrNull() ?: throw BadRequestException("Invalid int parameter: id")
                apiController.getProduct(call, id)
            }
            get("/api/search") {
                val q: String = call.request.queryParameters["q"] ?: throw BadRequestException("Missing query parameter: q")
                apiController.search(call, q)
            }
        }
    }
}
```

## Routes File Syntax

The routes file uses [the Play! Framework routes files syntax](https://www.playframework.com/documentation/3.0.x/JavaRouting#The-routes-file-syntax):

```
METHOD    PATH    controller.ACTION(parameters)
```

(See [the example above](#3-create-the-routes-file))

### HTTP Methods
- `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `OPTIONS`

### Path Parameters
Path parameters are prefixed with a colon in the PATH element, so it looks something like this:
`/fixedPart/:var1/moreFixedPath/:var2`. For this path element, you would need to use both `var1` and `var2` in your
controller call, e.g. like this: `com.package.controller.action(var1: String, var2: Int)`. All path parameters must be
used in the controller function call.

### Query Parameters
If you include parameters in the ACTION that are not specified in the PATH, they will be included as query parameters.
So with this line in the routes file:
```routes
GET /some/path  com.package.controller.action(extra: String)
```
the generated code will expect `extra` to be included as a query parameter.


### Parameter Types
The type of the path variables is determined by the function signature you supply in the ACTION clause. Supported types
are:
- `String`
- `Int`
- `Long`
- `Boolean`
- `Double`
- `Float`

The type given in the ACTION clause in the routes file must match the type in the function signature in your controller
class, otherwise the build will fail.


## Controllers
Controller / request handler functions must be specified with an `ApplicationCall` as a first parameter. So if you
define a path with no dynamic parts, like this: `/static/path/here`, your ACTION should still be defined _with_ an
`ApplicationCall`, like this: 
```kotlin
  fun staticResource(call: ApplicationCall) {
      ...
  }
```
The `ApplicationCall` must always be the _first_ parameter, so your own parameters will follow _after_ this initial
`call: ApplicationCall`.

## Validation

The code generator performs strict validation:

- **Path parameters must match function parameters**: If your path has `:id`, your function must also have `id: (Type)`
- **Controller classes must exist**: The code generator verifies that all referenced controller classes can be found. If
  you insert a line in the routes file before you create the function, the build will fail (until you write the
  function).
- **Valid identifiers**: Controller and function names must be valid Kotlin identifiers


## Configuration

### Custom Routes File Path

You may specify a different name for your routes file path thus:
```kotlin
@GenerateRoutes(routesFile = "myRoutes")
class RoutesConfig
```

The code generator will look for the routes file in these locations:
 
1. `src/main/resources/{routesFile}` (standard maven location for resource files)
2. Exact path as specified (so in the example above, a file named `myRoutes` in the project root folder)


## License

This project is licensed under the [MIT License](LICENSE).

## Contributing

Contributions are welcome! Please feel free to submit issues and PRs.

